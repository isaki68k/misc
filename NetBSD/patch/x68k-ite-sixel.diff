X68k の ite(4) で SIXEL 画像を表示できるようにするネタパッチです。
このパッチをあてて GENERIC カーネルをビルドするだけで使えるように
なります。

o ITE_SIXEL を定義すると SIXEL 画像のデコードをサポートします。

o ITE_16COLOR を定義すると、ite を 16色モードにします。
  今のところ前半8色は変更なし、後半8色を拡張していますので、
  従来の x68k 8色モードとは互換性がありますが、逆に世間の16色モードとは
  互換性がありません。

o ITE_SYSCTL を定義すると、テキストパレットを sysctl で取得・変更
  できるようになります。sysctl hw.ite.tpalette[0-F] です。

注意点など:

o SIXEL データのうちパレット定義は無視してパレット番号 = カラーコードと
  と解釈して使用しています。テキストVRAMのパレットを変えると、この画像
  以外の部分の色も変わってしまうためです。
  ITE_16COLOR オプションを定義しない場合は、デフォルトの ANSI(8色)を使用
  してください。img2sixel で減色する際はこれ
  ( https://github.com/isaki68k/sayaka/blob/master/colormap8.png )
  をとってきておいて

    $ img2sixel -m colormap8.png infile

  のように指定します。

o ITE_16COLOR オプションを定義した場合のカラーマップはこちら。
  https://github.com/isaki68k/sayaka/blob/feature-vala/colormapx68k16.png

o 異常系はほとんど実装してません。お手製のシーケンスを食わせたりしない
  ように :-)

Index: sys/arch/x68k/conf/GENERIC
===================================================================
RCS file: /cvsroot/src/sys/arch/x68k/conf/GENERIC,v
retrieving revision 1.180
diff -u -r1.180 GENERIC
--- sys/arch/x68k/conf/GENERIC	8 Aug 2015 06:36:26 -0000	1.180
+++ sys/arch/x68k/conf/GENERIC	17 Sep 2015 04:24:15 -0000
@@ -247,6 +247,9 @@
 ite0	at grf0 grfaddr 0		# internal terminal emulator
 options 	ITE_KERNEL_ATTR=4	# bold for kernel messages
 					# see /sys/arch/x68k/dev/itevar.h
+options 	ITE_SIXEL
+options 	ITE_16COLOR
+options 	ITE_SYSCTL
 
 ## floppy disks
 fdc0	at intio0 addr 0xe94000 intr 96 dma 0 dmaintr 100 # floppy controller
Index: sys/arch/x68k/conf/files.x68k
===================================================================
RCS file: /cvsroot/src/sys/arch/x68k/conf/files.x68k,v
retrieving revision 1.79
diff -u -r1.79 files.x68k
--- sys/arch/x68k/conf/files.x68k	2 Oct 2012 23:54:54 -0000	1.79
+++ sys/arch/x68k/conf/files.x68k	17 Sep 2015 04:24:15 -0000
@@ -66,6 +66,9 @@
 file	arch/x68k/dev/grf_gv.c		grf | ite
 
 defparam opt_ite.h	ITE_KERNEL_ATTR
+defflag opt_ite.h	ITE_SIXEL
+defflag opt_ite.h	ITE_16COLOR
+defflag opt_ite.h	ITE_SYSCTL
 device	ite : tty
 attach	ite at grf
 file	arch/x68k/dev/ite.c		ite needs-flag
Index: sys/arch/x68k/dev/ite.c
===================================================================
RCS file: /cvsroot/src/sys/arch/x68k/dev/ite.c,v
retrieving revision 1.63
diff -u -r1.63 ite.c
--- sys/arch/x68k/dev/ite.c	25 Jul 2014 08:10:35 -0000	1.63
+++ sys/arch/x68k/dev/ite.c	17 Sep 2015 04:24:16 -0000
@@ -87,6 +87,9 @@
 #define SUBR_CLEAR(ip,sy,sx,h,w)	ip->isw->ite_clear(ip,sy,sx,h,w)
 #define SUBR_SCROLL(ip,sy,sx,count,dir)	\
     ip->isw->ite_scroll(ip,sy,sx,count,dir)
+#if defined(ITE_SIXEL)
+#define SUBR_SIXEL(ip,sy,sx)	ip->isw->ite_sixel(ip,sy,sx)
+#endif
 
 struct consdev;
 
@@ -1193,7 +1196,11 @@
 	int n, x, y;
 	char *cp;
 
+#if defined(ITE_SIXEL)
+	if ((c >= 0x20 && ip->escape) || ip->escape == DCS) {
+#else
 	if (c >= 0x20 && ip->escape) {
+#endif
 		switch (ip->escape) {
 
 		case ESC:
@@ -1250,6 +1257,11 @@
 				/* String Terminator */
 				c = ST;
 				ip->escape = 0;
+#if defined(ITE_SIXEL)
+				if (ip->decsixel_y != 0) {
+					ite_lf(ip);
+				}
+#endif
 				break;
 
 			case ']':
@@ -1893,9 +1905,29 @@
 						break;
 
 					case '1':
+#if defined(ITE_16COLOR)
+						if (c_p[1] == '0') {
+							switch (c_p[2]) {
+							case '0': case '1': case '2': case '3':
+							case '4': case '5': case '6': case '7':
+								/* background colors */
+								ip->bgcolor = c_p[2] - '0' + 8;
+								c_p += 3;
+								break;
+							default:
+								c_p += 3;
+								break;
+							}
+						} else {
+							set_attr(ip, ATTR_BOLD);
+							c_p++;
+						}
+						break;
+#else
 						set_attr(ip, ATTR_BOLD);
 						c_p++;
 						break;
+#endif
 
 					case '2':
 						switch (c_p[1]) {
@@ -1964,6 +1996,22 @@
 						c_p++;
 						break;
 
+#if defined(ITE_16COLOR)
+					case '9':
+						switch (c_p[1]) {
+						case '0': case '1': case '2': case '3':
+						case '4': case '5': case '6': case '7':
+							/* foreground colors */
+							ip->fgcolor = c_p[1] - '0' + 8;
+							c_p += 2;
+							break;
+						default:
+							c_p++;
+							break;
+						}
+						break;
+#endif
+
 					default:
 						c_p++;
 						break;
@@ -2080,6 +2128,215 @@
 			}
 			break;
 
+#if defined(ITE_SIXEL)
+		case DCS:
+			switch (ip->dcs_cmd) {
+			case DCS_START:
+				/* the biggie... */
+				switch (c) {
+				case '0': case '1': case '2': case '3': case '4':
+				case '5': case '6': case '7': case '8': case '9':
+				case ';': case '$':
+					if (ip->ap < ip->argbuf + MAX_ARGSIZE)
+						*ip->ap++ = c;
+					return;
+
+				case 'q':
+					/* init sixel */
+					/* XXX ignore aspect-ratio and background color mode */
+					ip->ap = ip->argbuf;
+					ip->dcs_cmd = DCS_SIXEL;
+					ip->decsixel_state = DECSIXEL_INIT;
+					ip->decsixel_x = 0;
+					ip->decsixel_y = 0;
+					ip->decsixel_repcount = 0;
+					ip->decsixel_color = ip->fgcolor;
+					memset(ip->decsixel_buf, 0, sizeof(ip->decsixel_buf));
+					return;
+
+				case CAN:
+				case SUB:
+					/* SUB should also display a reverse question mark... */
+					ip->escape = 0;
+					return;
+
+				case ESC:
+					ip->escape = ESC;
+					return;
+
+				default:
+					return;
+				}
+				break;
+
+			case DCS_SIXEL:
+ sixel_loop:
+				switch (ip->decsixel_state) {
+				case DECSIXEL_INIT:
+					switch (c) {
+					case CAN:
+					case SUB:
+						/* SUB should also display a reverse question mark... */
+						ip->escape = 0;
+						return;
+					case ESC:
+						ip->escape = ESC;
+						return;
+					case DECSIXEL_REPEAT:
+						ip->decsixel_state = c;
+						ip->decsixel_repcount = 0;
+						return;
+					case DECSIXEL_RASTER:
+					case DECSIXEL_COLOR:
+						ip->decsixel_state = c;
+						ip->ap = ip->argbuf;
+						return;
+					case '$':	// LF
+						ip->decsixel_x = 0;
+						return;
+					case '-':	// CR
+						/* XXX FONTHEIGHT is defined in ite_tv.c, not here... */
+						if (ip->decsixel_y + 6 > 15) {
+							ite_lf(ip);
+							ip->decsixel_y -= 16;
+						}
+						SUBR_SIXEL(ip, ip->cury, ip->curx);
+						memset(ip->decsixel_buf, 0, sizeof(ip->decsixel_buf));
+						ip->decsixel_x = 0;
+						ip->decsixel_y += 6;
+						return;
+					default:
+						if ('?' <= c && c <= '~'
+						 && ip->decsixel_x < MAX_SIXEL_WIDTH) {
+							int sx = ip->decsixel_x;
+							c -= '?';
+							if ((c & 0x01) != 0)
+								ip->decsixel_buf[0][sx] = ip->decsixel_color;
+							if ((c & 0x02) != 0)
+								ip->decsixel_buf[1][sx] = ip->decsixel_color;
+							if ((c & 0x04) != 0)
+								ip->decsixel_buf[2][sx] = ip->decsixel_color;
+							if ((c & 0x08) != 0)
+								ip->decsixel_buf[3][sx] = ip->decsixel_color;
+							if ((c & 0x10) != 0)
+								ip->decsixel_buf[4][sx] = ip->decsixel_color;
+							if ((c & 0x20) != 0)
+								ip->decsixel_buf[5][sx] = ip->decsixel_color;
+							ip->decsixel_x++;
+						} else {
+							/* ignore */
+						}
+						return;
+					}
+					break;
+				case DECSIXEL_REPEAT:
+					if ('0' <= c && c <= '9') {
+						ip->decsixel_repcount = ip->decsixel_repcount * 10
+							+ (c - '0');
+					} else {
+						int cnt = min(ip->decsixel_repcount,
+							MAX_SIXEL_WIDTH - ip->decsixel_x);
+						c -= '?';
+						if ((c & 0x01) != 0) {
+							memset(&ip->decsixel_buf[0][ip->decsixel_x],
+								ip->decsixel_color, cnt);
+						}
+						if ((c & 0x02) != 0) {
+							memset(&ip->decsixel_buf[1][ip->decsixel_x],
+								ip->decsixel_color, cnt);
+						}
+						if ((c & 0x04) != 0) {
+							memset(&ip->decsixel_buf[2][ip->decsixel_x],
+								ip->decsixel_color, cnt);
+						}
+						if ((c & 0x08) != 0) {
+							memset(&ip->decsixel_buf[3][ip->decsixel_x],
+								ip->decsixel_color, cnt);
+						}
+						if ((c & 0x10) != 0) {
+							memset(&ip->decsixel_buf[4][ip->decsixel_x],
+								ip->decsixel_color, cnt);
+						}
+						if ((c & 0x20) != 0) {
+							memset(&ip->decsixel_buf[5][ip->decsixel_x],
+								ip->decsixel_color, cnt);
+						}
+						ip->decsixel_x += ip->decsixel_repcount;
+						ip->decsixel_repcount = 0;
+						ip->decsixel_state = DECSIXEL_INIT;
+					}
+					return;
+				case DECSIXEL_RASTER:
+				case DECSIXEL_RASTER_PAD:
+				case DECSIXEL_RASTER_PH:
+				case DECSIXEL_RASTER_PV:
+					switch (c) {
+					case '0': case '1': case '2': case '3': case '4':
+					case '5': case '6': case '7': case '8': case '9':
+						if (ip->ap < ip->argbuf + MAX_ARGSIZE)
+							*ip->ap++ = c;
+						return;
+					case ';':
+					default:
+						switch (ip->decsixel_state) {
+						case DECSIXEL_RASTER:
+							/* ignore PAN */
+							ip->ap = ip->argbuf;
+							ip->decsixel_state = DECSIXEL_RASTER_PAD;
+							return;
+						case DECSIXEL_RASTER_PAD:
+							/* ignore PAD */
+							ip->ap = ip->argbuf;
+							ip->decsixel_state = DECSIXEL_RASTER_PH;
+							return;
+						case DECSIXEL_RASTER_PH:
+							ip->decsixel_ph = ite_zargnum(ip);
+							ip->ap = ip->argbuf;
+							ip->decsixel_state = DECSIXEL_RASTER_PV;
+							return;
+						case DECSIXEL_RASTER_PV:
+							ip->decsixel_pv = ite_zargnum(ip);
+							ip->decsixel_state = DECSIXEL_INIT;
+							/* c is a next sequence char */
+							goto sixel_loop;
+						default:
+							/* NOTREACHED */
+							return;
+						}
+					}
+					return;
+				case DECSIXEL_COLOR:
+					switch (c) {
+					case '0': case '1': case '2': case '3': case '4':
+					case '5': case '6': case '7': case '8': case '9':
+					case ';':
+						if (ip->ap < ip->argbuf + MAX_ARGSIZE)
+							*ip->ap++ = c;
+						return;
+					default:
+						*ip->ap = '\0';
+						if (strchr(ip->argbuf, ';')) {
+							/* ignore the palette definition */
+						} else {
+							/* otherwise, it specifies color */
+#if defined(ITE_16COLOR)
+							ip->decsixel_color = ite_zargnum(ip) & 15;
+#else
+							ip->decsixel_color = ite_zargnum(ip) & 7;
+#endif
+						}
+						ip->decsixel_state = DECSIXEL_INIT;
+						ip->ap = ip->argbuf;
+						/* c is a next sequence char */
+						goto sixel_loop;
+					}
+					return;
+				}
+				break;
+			}
+			break;
+#endif /* ITE_SIXEL */
+
 
 		default:
 			ip->escape = 0;
@@ -2207,6 +2464,9 @@
 		
 	case DCS:	/* device control string introducer */
 		ip->escape = DCS;
+#if defined(ITE_SIXEL)
+		ip->dcs_cmd = DCS_START;
+#endif
 		ip->ap = ip->argbuf;
 		break;
 		
Index: sys/arch/x68k/dev/ite_tv.c
===================================================================
RCS file: /cvsroot/src/sys/arch/x68k/dev/ite_tv.c,v
retrieving revision 1.16
diff -u -r1.16 ite_tv.c
--- sys/arch/x68k/dev/ite_tv.c	28 Apr 2013 14:44:46 -0000	1.16
+++ sys/arch/x68k/dev/ite_tv.c	17 Sep 2015 04:24:16 -0000
@@ -33,10 +33,15 @@
 #include <sys/cdefs.h>
 __KERNEL_RCSID(0, "$NetBSD: ite_tv.c,v 1.16 2013/04/28 14:44:46 isaki Exp $");
 
+#include "opt_ite.h"
+
 #include <sys/param.h>
 #include <sys/device.h>
 #include <sys/proc.h>
 #include <sys/systm.h>
+#if defined(ITE_SYSCTL)
+#include <sys/sysctl.h>
+#endif
 
 #include <machine/bus.h>
 #include <machine/grfioctl.h>
@@ -71,6 +76,9 @@
 
 u_int  tv_top;
 u_char *tv_row[PLANELINES];
+#if defined(ITE_SIXEL)
+u_char *tv_end;
+#endif
 char   *tv_font[256];
 volatile char *tv_kfont[0x7f];
 
@@ -90,6 +98,9 @@
 void tv_cursor(struct ite_softc *, int);
 void tv_clear(struct ite_softc *, int, int, int, int);
 void tv_scroll(struct ite_softc *, int, int, int, int);
+#if defined(ITE_SIXEL)
+void tv_sixel(struct ite_softc *, int, int);
+#endif
 
 inline static int expbits(int);
 inline static void txrascpy(u_char, u_char, short, signed short);
@@ -166,6 +177,9 @@
 	tv_top = 0;
 	for (i = 0; i < PLANELINES; i++)
 		tv_row[i] = (void *)__UNVOLATILE(&IODEVbase->tvram[ROWOFFSET(i)]);
+#if defined(ITE_SIXEL)
+	tv_end = (void *)__UNVOLATILE(&IODEVbase->tvram[ROWOFFSET(i)]);
+#endif
 	/* shadow ANK font */
 	memcpy(kern_font, (void *)&IODEVbase->cgrom0_8x16, 256 * FONTHEIGHT);
 	ite_set_glyph();
@@ -189,6 +203,9 @@
 	ip->isw->ite_cursor = tv_cursor;
 	ip->isw->ite_clear  = tv_clear;
 	ip->isw->ite_scroll = tv_scroll;
+#if defined(ITE_SIXEL)
+	ip->isw->ite_sixel  = tv_sixel;
+#endif
 
 	/*
 	 * Intialize colormap
@@ -204,6 +221,20 @@
 	IODEVbase->tpalet[5] = 1 | BLUE | RED;		/* magenta */
 	IODEVbase->tpalet[6] = 1 | BLUE | GREEN;	/* cyan */
 	IODEVbase->tpalet[7] = 1 | BLUE | RED | GREEN;	/* white */
+
+#if defined(ITE_16COLOR)
+#define hRED   (0x0f << 6)
+#define hBLUE  (0x0f << 1)
+#define hGREEN (0x0f << 11)
+	IODEVbase->tpalet[8]  = 1 | (0x17 << 1) | (0x17 << 6) | ( 0x17 << 11);
+	IODEVbase->tpalet[9]  = 1 | hRED;
+	IODEVbase->tpalet[10] = 1 | hGREEN;
+	IODEVbase->tpalet[11] = 1 | hRED | hGREEN;
+	IODEVbase->tpalet[12] = 1 | hBLUE;
+	IODEVbase->tpalet[13] = 1 | hBLUE | hRED;
+	IODEVbase->tpalet[14] = 1 | hBLUE | hGREEN;
+	IODEVbase->tpalet[15] = 1 | hBLUE | hRED | hGREEN;
+#endif	/* ITE_16COLOR */
 }
 
 /*
@@ -726,3 +757,122 @@
 		break;
 	}
 }
+
+#if defined(ITE_SIXEL)
+/*
+ * put SIXEL graphics
+ */
+void
+tv_sixel(struct ite_softc *ip, int sy, int sx)
+{
+	uint8_t *p;
+	int width;
+	int y;
+	int cx;
+	int px;
+#if defined(ITE_16COLOR)
+	uint16_t data[4];
+#else
+	uint16_t data[3];
+#endif
+	uint8_t color;
+
+	width = min(ip->decsixel_ph, MAX_SIXEL_WIDTH);
+	width = min(width, PLANEWIDTH - sx * FONTWIDTH);
+
+	p = CHADDR(sy, sx);
+	p += ROWBYTES * ip->decsixel_y;
+	/* boundary check */
+	if (p < tv_row[0]) {
+		p = tv_end + (p - tv_row[0]);
+	}
+
+	for (y = 0; y < 6; y++) {
+		/* for each 16dot word */
+		for (cx = 0; cx < howmany(width, 16); cx++) {
+			data[0] = 0;
+			data[1] = 0;
+			data[2] = 0;
+#if defined(ITE_16COLOR)
+			data[3] = 0;
+#endif
+			for (px = 0; px < 16; px++) {
+				color = ip->decsixel_buf[y][cx * 16 + px];
+				/* x68k console is 8 colors */
+				data[0] = (data[0] << 1) | ((color >> 0) & 1);
+				data[1] = (data[1] << 1) | ((color >> 1) & 1);
+				data[2] = (data[2] << 1) | ((color >> 2) & 1);
+#if defined(ITE_16COLOR)
+				data[3] = (data[3] << 1) | ((color >> 3) & 1);
+#endif
+			}
+			*(uint16_t *)(p + cx * 2          ) = data[0];
+			*(uint16_t *)(p + cx * 2 + 0x20000) = data[1];
+			*(uint16_t *)(p + cx * 2 + 0x40000) = data[2];
+#if defined(ITE_16COLOR)
+			*(uint16_t *)(p + cx * 2 + 0x60000) = data[3];
+#endif
+		}
+
+		p += ROWBYTES;
+		if (p >= tv_end) {
+			p = tv_row[0] + (p - tv_end);
+		}
+	}
+}
+#endif /* ITE_SIXEL */
+
+#if defined(ITE_SYSCTL)
+static int
+sysctl_hw_ite_textpalette(SYSCTLFN_ARGS)
+{
+	struct sysctlnode node;
+	int idx;
+	int error;
+	int t;
+
+	node = *rnode;
+	idx = node.sysctl_name[strlen("tpalette")] - '0';
+	if (idx > 9)
+		idx -= 7;
+	t = (int)(IODEVbase->tpalet[idx]);
+
+	node.sysctl_data = &t;
+
+	error = sysctl_lookup(SYSCTLFN_CALL(&node));
+	if (error || newp == NULL)
+		return error;
+
+	if (t < 0 || t > 65535)
+		return EINVAL;
+
+	IODEVbase->tpalet[idx] = t;
+
+	return 0;
+}
+
+SYSCTL_SETUP(sysctl_ite_setup, "sysctl hw.ite setup")
+{
+	char name[16];
+	const struct sysctlnode *node;
+	int i;
+
+	sysctl_createv(NULL, 0, NULL, &node,
+	    CTLFLAG_PERMANENT, CTLTYPE_NODE,
+	    "ite", SYSCTL_DESCR("ite"),
+	    NULL, 0, NULL, 0,
+	    CTL_HW, CTL_CREATE, CTL_EOL);
+	if (node == NULL)
+		return;
+
+	for (i = 0; i < 16; i++) {
+		snprintf(name, sizeof(name), "tpalette%X", i);
+		sysctl_createv(NULL, 0, NULL, NULL,
+		    CTLFLAG_PERMANENT | CTLFLAG_READWRITE,
+		    CTLTYPE_INT,
+		    name, SYSCTL_DESCR("text palette"),
+		    sysctl_hw_ite_textpalette, 0, NULL, 0,
+		    CTL_HW, node->sysctl_num, CTL_CREATE, CTL_EOL);
+	}
+}
+#endif /* ITE_SYSCTL */
Index: sys/arch/x68k/dev/itevar.h
===================================================================
RCS file: /cvsroot/src/sys/arch/x68k/dev/itevar.h,v
retrieving revision 1.15
diff -u -r1.15 itevar.h
--- sys/arch/x68k/dev/itevar.h	10 Oct 2012 17:49:50 -0000	1.15
+++ sys/arch/x68k/dev/itevar.h	17 Sep 2015 04:24:16 -0000
@@ -50,6 +50,7 @@
 	void	(*ite_putc)(struct ite_softc *, int, int, int, int);
 	void	(*ite_cursor)(struct ite_softc *, int);
 	void	(*ite_scroll)(struct ite_softc *, int, int, int, int);
+	void	(*ite_sixel)(struct ite_softc *, int, int);
 };
 
 enum ite_arraymaxs {
@@ -94,6 +95,27 @@
 	short	save_curx, save_cury, save_attribute, save_char;
 	char	sc_G0, sc_G1, sc_G2, sc_G3;
 	char	*sc_GL, *sc_GR;
+	enum {
+		DCS_START = 0,
+		DCS_SIXEL = 'q',	// DECRQSS also use 'q'... 
+	} dcs_cmd;
+	enum {
+		DECSIXEL_INIT = 0,
+		DECSIXEL_RASTER_PAD,
+		DECSIXEL_RASTER_PH,
+		DECSIXEL_RASTER_PV,
+		DECSIXEL_REPEAT = '!',
+		DECSIXEL_RASTER = '\"',
+		DECSIXEL_COLOR = '#',
+	} decsixel_state;
+	int     decsixel_ph;
+	int     decsixel_pv;
+	int     decsixel_x;
+	int     decsixel_y;
+	int		decsixel_repcount;
+	int     decsixel_color;
+#define MAX_SIXEL_WIDTH (768)
+	u_char  decsixel_buf[6][MAX_SIXEL_WIDTH];
 };
 
 enum emul_level {
